defmodule Cmplx do
    #@type cmplx :: {:cmplx, real(), imaginary()}
    def new(r, i) do
        {:cmplx, r, i}
    end
    def add({:cmplx, ra, ia}, {:cmplx, rb, ib}) do
        {:cmplx, (ra + rb), (ia + ib)}
    end
    def sqr({:cmplx, r, i}) do
        {:cmplx, (r*r) - (i*i), 2*r*i}
    end
    def abs({:cmplx, r,i}) do
        :math.sqrt(((r*r) + (i*i)))
    end
end
 
defmodule Brot do
    def mandelbrot({:cmplx, r, i} = c, m) do
        z0 = Cmplx.new(0, 0)
        i = 0
        test(i, z0, c, m)
    end
    def test(i, z0, c, 0) do
        0
    end
    def test(i, z0, c, m) do
        if Cmplx.abs(z0) > 2 do
            i
        else
            test(i + 1, Cmplx.add(Cmplx.sqr(z0), c), c, m-1)
        end
    end
end
 
defmodule PPM do
 
  # write(name, image) The image is a list of rows, each row a list of
  # tuples {R,G,B}. The RGB values are 0-255.
 
  def write(name, image) do
    height = length(image)
    width = length(List.first(image))
    {:ok, fd} = File.open(name, [:write])
    IO.puts(fd, "P6")
    IO.puts(fd, "#generated by ppm.ex")
    IO.puts(fd, "#{width} #{height}")
    IO.puts(fd, "255")
    rows(image, fd)
    File.close(fd)
  end
 
  defp rows(rows, fd) do
    Enum.each(rows, fn(r) ->
      colors = row(r)
      IO.write(fd, colors)
    end)
  end
 
  defp row(row) do
    List.foldr(row, [], fn({:rgb, r, g, b}, a) ->
      [r, g, b | a]
    end)
  end
 
end
 
defmodule Color do
    def convert(depth, max) do
        a = depth/max * 4
        x = trunc(a)
        y = trunc(255*(a-x))
        case x do
            0 -> {:rgb, y,0,0}
            1 -> {:rgb, 255,y,0}
            2 -> {:rgb, 255-y, 255, 0}
            3 -> {:rgb, 0, 255, y}
            4 -> {:rgb, 0, 255-y, 255}
        end
    end
 
end
 
defmodule Mandel do
    def mandelbrot(width, height, x, y, k, depth) do
        trans = fn(w, h) ->
            Cmplx.new(x+k*(w-1), y-k*(h-1))
        end
        rows(width, height, trans, depth, [])
    end
 	def rows(width, 0, trans, depth, rows) do
 		rows
 	end
    def rows(width, height, trans, depth, rows) do
    	row = row(width, height, trans, depth, [])
    	rows(width, height - 1, trans, depth,[row|rows])
 	end

 	def row(width, height, trans, depth, row) do
 		if width > 0 do
 			compNumber = trans.(width, height)
       	 	depthOfComp = Brot.mandelbrot(compNumber, depth)
        	colorOfComp = Color.convert(depthOfComp, depth)
        	row(width - 1, height, trans, depth, [colorOfComp | row])
 		else
 			row
 		end
 	end
end
 
defmodule Test do
    def demo() do
        small(-2.6, 1.2, 1.2)
    end
    def small(x0, y0, xn) do
        width = 960
        height = 540
        depth = 90
        k = (xn - x0) / width
        image = Mandel.mandelbrot(width, height, x0, y0, k, depth)
        PPM.write("small.ppm", image)
    end
 
end